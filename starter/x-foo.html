<script>
    (function () {
        var privaVar = 'I am private';

        Polymer('x-foo', {
            // Type hinting!!! Now Polymer knows 'widthBreak' is a typeof number.
            count: 900,

            // Not exposed by publish, and not in the registered in 'attributes'.
            publicVar: 'I am still not public',

            get maGlobal() {
                return this.$.globals.values.firstname + ' ' + this.$.globals.values.lastname;
            },

            // this acts like a property, not a function
            get maPublic() {
                return this.publicVar;
            },

            maPrivate: function() {
                return privaVar;
            },

            // FANCY PANTSERY GOING ON BELOW

            publish: {
                reflected: {
                    value: '',
                    // If the property value is an object, array, or function,
                    // the value is NEVER reflected, whether or not reflect is true.
                    // The best way to think of reflection is that it is for something that should
                    // be reflected in the DOM. A candidate for this would be 'disabled' or
                    // 'checked', things that make a difference to the styling of an element.
                    // It is NOT 2 way data binding!! It can however be used WITH data binding.
                    // If a two way bound attribute is not set to reflect, that attribute always
                    // shows up as the-attr="{{someValue}}" in the DOM.
                    // If name is set to reflect, the DOM attribute reflects the current value of
                    // someValue.
                    reflect: true
                },

                total: {
                    value: 0, // Type hinting?
                    reflect: true
                }
            },

            computed: {
                total: '+count + 50' // Notice the 'casting' of count to a Number
            },

            // EVENT DELEGATORS: Imperative stylee
            // This code is equivalent to adding an on-event handler directly on a <polymer-element>.
            eventDelegates: {
                up: 'onTap',
                down: 'onTap'
            },

            onTap: function (event, detail, sender) {
                console.log(event.type);
            },

            // CHANGE EVENTS
            totalChanged: function () {
                console.log(this.total);
            },

            // EVENT HANDLERS
            elementClick: function (event, detail, sender) {
                console.log('clicking the thing');
            },


            // LIFECYCLE PROPERTIES
            created: function () {
                console.log('I am created!');

                // Type hinting for an array or an object should take place in the created to avoid
                // shitty "shared state" issues. Fuck knows what that is.
                // Objects and arrays cannot be reflected.
                this.config = {};
                this.list = [];
            },

            ready: function () {
                console.log('I am ready!');
                console.log(this.maPrivate());
                console.log(this.maPublic);
                console.log('Count is type: ' + (typeof this.count));
            },

            attached: function () {
                console.log('I am attached!');
            },

            /**
             * Looks just like $scope.$watch from angular!
             */
            attributeChanged: function (attrName, oldVal, newVal) {
                console.log('The ' + attrName + ' attribute was changed!');
                console.log('It was ' + oldVal + ', and now it\'s ' + newVal);
            },

            domReady: function () {
                console.log('Tha DOM is ready!');
            },

            detached: function () {
                console.log('I am detached!');
            }
        });

    }());
</script>

<!--
    Name and constructor do not count as attributes here, and are not exposed in the composed DOM.
    This also means that they have nothing to do with the 'attributeChanged' life cycle property
-->
<polymer-element name="x-foo" class="x-foo" constructor="XFoo"

    attributes="count config list">
    <template>
        <app-globals id="globals"></app-globals>
        <!-- shadow DOM here -->
        <h1>BOOM</h1>
        <button>Click Me!</button>
        <div class="ma-name">
            <span id="firstname">{{$.globals.values.firstname}}</span>
            <span id="lastname">{{$.globals.values.lastname}}</span>
        </div>
        <div>
            <span>I am two way bound: {{count}}</span>
        </div>
    </template>
</polymer-element>
